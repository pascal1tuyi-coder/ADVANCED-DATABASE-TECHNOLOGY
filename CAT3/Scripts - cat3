
-
-- Use schema
-- 1️ Create the schema (only once)
CREATE SCHEMA IF NOT EXISTS healthnet;

-- 2️Tell PostgreSQL to use that schema
SET search_path TO healthnet;

-- 3️ Create your table inside it
CREATE TABLE patient (
  id SERIAL PRIMARY KEY,
  name VARCHAR(100) NOT NULL
);

-- Corrected PATIENT_MED table

CREATE TABLE patient_med (
  patient_med_id SERIAL PRIMARY KEY,  -- auto-increment unique ID
  patient_id INTEGER NOT NULL REFERENCES patient(id),  -- foreign key to patient
  med_name VARCHAR(80) NOT NULL,  -- medication name
  dose_mg NUMERIC(6,2) CHECK (dose_mg >= 0),  -- non-negative dose
  start_dt DATE,
  end_dt DATE,
  CONSTRAINT ck_rx_dates CHECK (
    start_dt IS NULL OR end_dt IS NULL OR start_dt <= end_dt
  )
);
 SELECT *FROM  patient_med;

 -- 1️ Negative dose violates CHECK constraint
INSERT INTO patient_med (
  patient_med_id,
  patient_id,
  med_name,
  dose_mg,
  start_dt,
  end_dt
)
VALUES (
  1,
  1,
  'Amoxicillin',
  -50,
  DATE '2025-10-01',
  DATE '2025-10-10'
);

-- 2️ Inverted dates violate ck_rx_dates constraint
INSERT INTO patient_med (
  patient_med_id,
  patient_id,
  med_name,
  dose_mg,
  start_dt,
  end_dt
)
VALUES (
  2,
  1,
  'Ibuprofen',
  200,
  DATE '2025-12-31',
  DATE '2025-10-12'
);

-- First, insert a valid patient
INSERT INTO patient (id, name)
VALUES (1, 'John Doe');

-- 1️ Valid prescription
INSERT INTO patient_med (
  patient_med_id,
  patient_id,
  med_name,
  dose_mg,
  start_dt,
  end_dt
)
VALUES (
  3,
  1,
  'Paracetamol',
  500,
  DATE '2025-10-01',
  DATE '2025-10-05'
);

-- 2️ Valid prescription with NULL dates
INSERT INTO patient_med (
  patient_med_id,
  patient_id,
  med_name,
  dose_mg,
  start_dt,
  end_dt
)
VALUES (
  4,
  1,
  'Cetirizine',
  10,
  NULL,
  NULL
);

 SELECT *FROM  patient_med;
 
 CREATE OR REPLACE FUNCTION trg_bill_total_stmt_fn()
RETURNS TRIGGER AS $$
DECLARE
  v_bill_id INTEGER;
BEGIN
  -- For all affected bill IDs, update totals
  FOR v_bill_id IN
    SELECT DISTINCT bill_id FROM bill_item WHERE bill_id IS NOT NULL
  LOOP
    -- Example: update the bill total for each affected bill
    UPDATE bill
    SET total_amount = (
      SELECT COALESCE(SUM(amount), 0)
      FROM bill_item
      WHERE bill_id = v_bill_id
    )
    WHERE id = v_bill_id;
  END LOOP;

  RETURN NULL;  -- statement-level trigger, no row return
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_bill_total_stmt
AFTER INSERT OR UPDATE OR DELETE ON bill_item
FOR EACH STATEMENT
EXECUTE FUNCTION trg_bill_total_stmt_fn();

CREATE TABLE bill (
  id SERIAL PRIMARY KEY,
  total_amount NUMERIC(10,2)
);

CREATE TABLE bill_item (
  id SERIAL PRIMARY KEY,
  bill_id INT REFERENCES bill(id),
  amount NUMERIC(10,2)
);


-- 1️ Audit and total update function
CREATE OR REPLACE FUNCTION trg_bill_total_stmt_fn()
RETURNS TRIGGER AS $$
DECLARE
  v_bill_id INTEGER;
  v_old_total bill.total%TYPE;
  v_new_total bill.total%TYPE;
BEGIN
  -- Loop over all affected bill IDs
  FOR v_bill_id IN
    SELECT DISTINCT bill_id
    FROM bill_item
    WHERE bill_id IS NOT NULL
  LOOP
    -- Get old total (if any)
    SELECT total INTO v_old_total
    FROM bill
    WHERE id = v_bill_id;

    -- Compute new total from items
    SELECT COALESCE(SUM(amount), 0) INTO v_new_total
    FROM bill_item
    WHERE bill_id = v_bill_id;

    -- Update bill total
    UPDATE bill
    SET total = v_new_total
    WHERE id = v_bill_id;

    -- Insert audit record
    INSERT INTO bill_audit (bill_id, old_total, new_total, changed_at)
    VALUES (v_bill_id, v_old_total, v_new_total, CURRENT_TIMESTAMP);
  END LOOP;

  RETURN NULL; -- statement-level trigger
END;
$$ LANGUAGE plpgsql;

-- 2️ Create the trigger

CREATE TRIGGER trg_bill_total_stmt
AFTER INSERT OR UPDATE OR DELETE ON bill_item
FOR EACH STATEMENT
EXECUTE FUNCTION trg_bill_total_stmt_fn();

CREATE TABLE bill (
  id SERIAL PRIMARY KEY,
  total NUMERIC(10,2) DEFAULT 0
);

CREATE TABLE bill_item (
  id SERIAL PRIMARY KEY,
  bill_id INT REFERENCES bill(id),
  amount NUMERIC(10,2)
);

-- Create audit table
CREATE TABLE bill_audit (
  audit_id SERIAL PRIMARY KEY,
  bill_id INT,
  old_total NUMERIC(10,2),
  new_total NUMERIC(10,2),
  changed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Insert bill items (assuming bill_item table exists)
INSERT INTO bill_item (bill_id, amount)
VALUES (1, 100);

INSERT INTO bill_item (bill_id, amount)
VALUES (1, 200);

INSERT INTO bill_item (bill_id, amount)
VALUES (2, 300);

-- Insert with created_at explicitly
INSERT INTO bill_item (bill_id, amount, created_at) 
VALUES (1, 100, CURRENT_TIMESTAMP);



-- Update an item (trigger fires)
UPDATE bill_item
SET amount = 150
WHERE bill_id = 1 AND amount = 100;

-- Delete an item (trigger fires)
DELETE FROM bill_item
WHERE bill_id = 2 AND amount = 300;

-- Delete an item (trigger fires)
DELETE FROM bill_item
WHERE bill_id = 2 AND amount = 300;

SELECT * FROM BILL;

CREATE TABLE bill_audit (
  audit_id SERIAL PRIMARY KEY,
  bill_id INT,
  old_total NUMERIC(10,2),
  new_total NUMERIC(10,2),
  changed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);


SELECT * 
FROM BILL_AUDIT 
ORDER BY CHANGED_AT;

WITH RECURSIVE SUPERS (EMP, SUP, HOPS, PATH) AS (
  -- Anchor: start with direct supervision
  SELECT EMPLOYEE, SUPERVISOR, 1, EMPLOYEE || '>' || SUPERVISOR
  FROM STAFF_SUPERVISOR

  UNION ALL

  -- Recursive: climb up the supervision chain
  SELECT S.EMPLOYEE, T.SUP, T.HOPS + 1, T.PATH || '>' || T.SUP
  FROM STAFF_SUPERVISOR S
  JOIN SUPERS T ON S.SUPERVISOR = T.EMP
  WHERE STRPOS(T.PATH, T.SUP) = 0  -- cycle guard
)
-- Final selection: top supervisor per employee
SELECT EMP, SUP AS TOP_SUPERVISOR, HOPS
FROM (
  SELECT EMP, SUP, HOPS,
         RANK() OVER (PARTITION BY EMP ORDER BY HOPS DESC) AS RANK
  FROM SUPERS
) AS ranked
WHERE RANK = 1;


SELECT table_name
FROM information_schema.tables
WHERE table_name = 'isa';

---Check if the table exists

CREATE TABLE isa (
    ancestor VARCHAR(100),
    child VARCHAR(100)
);

-- Sample data
INSERT INTO isa (ancestor, child) VALUES
('Disease', 'InfectiousDisease'),
('Disease', 'GeneticDisease'),
('InfectiousDisease', 'ViralInfection'),
('InfectiousDisease', 'BacterialInfection'),
('ViralInfection', 'Flu'),
('ViralInfection', 'COVID19');

--- Recursive query to get all descendants of 'InfectiousDisease'

WITH RECURSIVE descendants AS (
  -- Base case: start from the ancestor
  SELECT ancestor, child
  FROM isa
  WHERE ancestor = 'InfectiousDisease'
  
  UNION ALL
  
  -- Recursive: follow children
  SELECT d.ancestor, i.child
  FROM isa i
  JOIN descendants d ON i.ancestor = d.child
)
SELECT * FROM descendants;

CREATE TABLE TRIPLE (
  S VARCHAR(100),
  P VARCHAR(50),
  O VARCHAR(100)
);
CREATE TABLE TRIPLE (
  S TEXT,
  P TEXT,
  O TEXT
);

-- Patient diagnoses
INSERT INTO TRIPLE (S, P, O) VALUES ('patient1', 'hasDiagnosis', 'Influenza');
INSERT INTO TRIPLE (S, P, O) VALUES ('patient2', 'hasDiagnosis', 'COVID19');
INSERT INTO TRIPLE (S, P, O) VALUES ('patient3', 'hasDiagnosis', 'Malaria');
INSERT INTO TRIPLE (S, P, O) VALUES ('patient4', 'hasDiagnosis', 'Diabetes');

INSERT INTO TRIPLE (S, P, O) VALUES
('patient1', 'hasDiagnosis', 'Influenza'),
('patient2', 'hasDiagnosis', 'COVID19'),
('patient3', 'hasDiagnosis', 'Malaria'),
('patient4', 'hasDiagnosis', 'Diabetes');

SELECT * FROM TRIPLE;

WITH RECURSIVE ISA(ANCESTOR, CHILD) AS (
  -- Anchor: direct isA relationships
  SELECT O, S
  FROM TRIPLE
  WHERE P = 'isA'

  UNION ALL

  -- Recursive: climb up the taxonomy (transitive closure)
  SELECT I.ANCESTOR, T.S
  FROM TRIPLE T
  JOIN ISA I ON T.P = 'isA' AND T.O = I.CHILD
),
INFECTIOUS_PATIENTS AS (
  SELECT DISTINCT T.S
  FROM TRIPLE T
  JOIN ISA ON T.O = ISA.CHILD
  WHERE T.P = 'hasDiagnosis'
    AND ISA.ANCESTOR = 'InfectiousDisease'
)
SELECT S AS PATIENT_ID
FROM INFECTIOUS_PATIENTS;

-- Disease hierarchy
INSERT INTO TRIPLE (S, P, O) VALUES
('ViralInfection', 'isA', 'InfectiousDisease'),
('BacterialInfection', 'isA', 'InfectiousDisease'),
('Flu', 'isA', 'ViralInfection'),
('COVID19', 'isA', 'ViralInfection'),
('Malaria', 'isA', 'InfectiousDisease');

-- Patients
INSERT INTO TRIPLE (S, P, O) VALUES
('patient1', 'hasDiagnosis', 'Influenza'),
('patient2', 'hasDiagnosis', 'COVID19'),
('patient3', 'hasDiagnosis', 'Malaria'),
('patient4', 'hasDiagnosis', 'Diabetes');


WITH RECURSIVE isa(ancestor, child) AS (
  -- Base case: direct isA relationships
  SELECT o, s
  FROM triple
  WHERE p = 'isA'

  UNION ALL

  -- Recursive: follow hierarchy upward
  SELECT i.ancestor, t.s
  FROM triple t
  JOIN isa i ON t.p = 'isA' AND t.o = i.child
),
infectious_patients AS (
  SELECT DISTINCT t.s AS patient_id, t.o AS diagnosis
  FROM triple t
  JOIN isa ON t.o = isa.child
  WHERE t.p = 'hasDiagnosis'
    AND isa.ancestor = 'InfectiousDisease'
)
SELECT patient_id, diagnosis
FROM infectious_patients;

CREATE EXTENSION postgis;

CREATE TABLE clinic (
  clinic_id SERIAL PRIMARY KEY,
  name TEXT,
  geom GEOMETRY(Point, 4326)
);


WITH RECURSIVE ISA(ANCESTOR, CHILD) AS (
  -- Base case: direct isA relationships
  SELECT O, S
  FROM TRIPLE
  WHERE P = 'isA'

  UNION ALL

  -- Recursive: follow isA hierarchy upward
  SELECT I.ANCESTOR, T.S
  FROM TRIPLE T
  JOIN ISA I ON T.P = 'isA' AND T.O = I.CHILD
),
INFECTIOUS_PATIENTS AS (
  SELECT DISTINCT T.S AS patient_id, T.O AS diagnosis
  FROM TRIPLE T
  JOIN ISA ON T.O = ISA.CHILD
  WHERE T.P = 'hasDiagnosis'
    AND ISA.ANCESTOR = 'InfectiousDisease'
)
SELECT patient_id, diagnosis
FROM INFECTIOUS_PATIENTS;

INSERT INTO USER_SDO_GEOM_METADATA
  (TABLE_NAME, COLUMN_NAME, DIMINFO, SRID)
VALUES (
  'CLINIC',
  'GEOM',
  SDO_DIM_ARRAY(
    SDO_DIM_ELEMENT('Longitude', 30.0, 31.0, 0.005),
    SDO_DIM_ELEMENT('Latitude', -2.5, -1.5, 0.005)
  ),
  4326
);
-- Enable PostGIS
CREATE EXTENSION IF NOT EXISTS postgis;

-- Create table with spatial column
CREATE TABLE clinic (
    clinic_id SERIAL PRIMARY KEY,
    name TEXT,
    geom GEOMETRY(Point, 4326)
);

-- Create spatial index
CREATE INDEX clinic_spx
ON clinic
USING GIST (geom);
SELECT name
FROM clinic
WHERE ST_DWithin(geom, ST_MakePoint(30.1, -1.9)::geography, 1000);

-- Enable PostGIS extension (only once per database)
CREATE EXTENSION IF NOT EXISTS postgis;

-- Create the CLINIC table with a spatial column
CREATE TABLE clinic (
  clinic_id SERIAL PRIMARY KEY,
  name TEXT,
  geom GEOMETRY(Point, 4326)
);

-- Insert clinic locations (WGS84 coordinates)
INSERT INTO clinic (clinic_id, name, geom) VALUES
(1, 'Kigali Central Clinic', ST_SetSRID(ST_MakePoint(30.0610, -1.9575), 4326)),
(2, 'Nyamirambo Health Center', ST_SetSRID(ST_MakePoint(30.0595, -1.9560), 4326)),
(3, 'Gikondo Medical', ST_SetSRID(ST_MakePoint(30.0700, -1.9500), 4326));

-- Create a spatial index
CREATE INDEX clinic_spx
ON clinic
USING GIST (geom);


-- Ambulance coordinates (longitude, latitude)
SELECT name,
       ST_Distance(
         geom::geography,
         ST_SetSRID(ST_MakePoint(30.0600, -1.9570), 4326)::geography
       ) AS distance_meters
FROM clinic
ORDER BY distance_meters
LIMIT 1;

SELECT C.ID, C.NAME
FROM CLINIC C
WHERE SDO_WITHIN_DISTANCE(
  C.GEOM,
  SDO_GEOMETRY(2001, 4326, SDO_POINT_TYPE(30.0600, -1.9570, NULL), NULL, NULL),
  'distance=1 unit=KM'
) = 'TRUE';


